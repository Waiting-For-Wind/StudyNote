`INT_MAX`是特殊字符表示INT类型的最大值。

## for循环 
不加等号时 不包含条件数字，加等号是包含条件数字。
不加等号时 运行次数等于条件数减初始数的绝对值，加等号时+1；

## ++ -- 递增递减运算符
在变量前时，是先进行递增运算，讲值赋完后，在进行其他运算
如
若`tmp2[0]`是1则会打印内容 因为`++`在变量前面，将递增后的值赋给变量之后才进行判断；

```cpp
if(++tmp2[0]==2)
        cout<<"++before==="<< tmp2[0]<<endl;
    return 0;
```

若`tmp2[0]`是1则不会打印任何东西 因为`++`在变量后面，本次判断完成后才将递增后的值赋给变量；
```cpp
if(tmp2[0]++==2)
        cout<<"++before==="<< tmp2[0]<<endl;
    return 0;
```

## 局部静态变量
在块内定义的变量的生命周期只存在于块内，若想让它从第一次被创建后一直存在可以设置局部静态变量，局部静态变量可以一直存在到程序终止。
定义局部静态对象的方式是在变量前加一个 ``static``


## 常量引用的作用
引用和指针的一个好处是它们比较迅速，实参把值传递给形参时，实际上是将值进行了拷贝，当我们不担心原本的参数被修改，或者我们不会修改它时，我们就可以使用引用和指针来作为形参，这样做如果传入的参数比较大时，我们就成功的避免了拷贝，增加了程序的运行效率，如果我们害怕不小心修改了输入的值，可以使用`const`来避免这种误修改，当我们要修改``const``时 编译器会报错，提醒我们修改了不该修改的值。这种操作就是我们常听到的**常量引用**                                                                                                                                

## 关于const
### const的层
说明一下顶层const啥的
```cpp
int i =5;
int * const p=&i; 
const int *cp =&i;
*cp=7;//错误，底层const不能改变i
*p=6;
```
这样就是 不可以给``p``赋值，但不影响``*p``。

### const 形参
```cpp
void fcn(const int i){/*能读取i但不能改写i*/}
void fcn(int i){/*出错了因为找个函数被重复定义了，*/}
```
可以看出 虽然两种看上去不一样，但是实际上编译器把他们看成是同一个函数了，也就是说，虽然`const`有作用，它并不是一个独立的类型。
实际上出错是因为函数的重载，函数的重载是根据输入和输出的区别来判断的，但是在上面的例子中，虽然形参表面上有所变化，但它**输入的类型并没有变化**

### 函数重载与const

```cpp
Record lookup(Account& n);		//新函数，作用于Account的引用
Record lookup(const Account& n);//新函数，作用于常量引用
Record lookup(Account* n);		//新函数，作用于指向Account的指针
Record lookup(const Account* n);//新函数，作用于指向常量的指针
Record lookup(Account n);		
Record lookup(const Account n);//错误，重复声明
Record lookup(Account* n);		
Record lookup(Account* const n);//错误，重复声明
```

注意它们的区别。`const`对象只能传递给`const`形参。


### 箭头运算符（->）和点运算符（.）
箭头运算符和点运算符类似，都可用于访问成员，其中，点运算符获取类对象的一个成员。箭头运算符与点运算符有关`prt->mem`和`(*ptr).mem`是等价的。
```cpp
string s1="a string".*p=&s1;
auto n=s1.size();
n=(*p).size();
n=p->size();
```
可以看出点运算符是面向对象的，而箭头运算符则可以用在指针上，<font color=red>`p.size()`</font>的表达方式是错误的，因为`p`是一个指针，而不是一个对象,此外<font color=red>`*p.size()`</font>这样的表达方式也是错误的，而<font color=green>`(*p).size()`</font>则是正确的，造成这一现象的主要原因是，解引用运算符`*`的优先级低于点运算符`.`所以加上括号才能正确的表达我们的意思。

### 返回数组指针

这里说一下``typedef``关键词，这个关键词就是给类型 重新设置一个名字，有些类型名非常长，就可以利用`typedef`关键词来重新赋予它一个名字，使其在使用时变得方便。

```cpp
typedef int arrT[10];//与下面的内容是等价的
using int arrT[10];//与上面的内容是等价的
arrT example{1,2,3,4,5,6,7,8,9,10};
for(int i=0;i<10;++i){
    cout<<example[i]<<endl;
}
```

以上代码可以打印`example`数组中的值，而`arrT`就代表了有十个`int`类型的数组。

这样做的一个应用就是我们可以方便的利用指针将数组返回。例如

```cpp
typedef int arrT[10];
arrT* func(int i);//func 函数返回一个指向含有十个int的数组的指针

arrT* func(int i){
    static int res;
    /*
    *
    *
    */
    return &res;
}
```

但需要注意的是，函数内返回的应该是要传送的数组的首**地址**，同时返回值也是地址，还有一点非常重要，我们不要忘了C++中变量的生命周期，我们声明返回的变量时一定要将其设置为静态变量，加上<font color=red>static</font>不然是没有办法返回这个指针的。~~目前能想到较好的使用方法是将函数的返回值设置成一个`arrT`类型的指针，然后再解引用就可以使用这个数组了。~~

```cpp
arrT* arrTprt;
arrTprt=func(1);
for(int i=0;i<10;++i){
    cout<<(*arrTprt)[i]<<endl;
}
```

上面的代码就可以打印出返回的数组的值了。

现在有了更好的办法，上面的办法有点蠢。

```cpp
for(int i=0;i<10;++i){
    cout<<(*func(1))[i]<<endl;
}
```

这回好多了，其实就是给函数返回的指针直接解指针，并且使用它。

那么如果我们不利于`typedef`关键词这个操作会变成什么样呢？

```cpp
int (*func(int i))[10];//函数的声明
int (*func(int i))[10]{//函数的定义
    /*。。。*/
}
```

这样可读性就降到非常低了。

在C++11中我们可以使用**尾置返回类型**

```cpp
auto func(int i)->int(*)[10];
```

如果我们知道函数返回的指针将指向哪个数组，我们就可以使用`decltype`关键字声明返回类型。

```cpp
int odd[]={1,3,5,7,9};
int even[]={0,2,4,6,8};
decltype(odd) *arrPtr(int i){
    return (i%2)? &odd:&even;
}
```

## 





