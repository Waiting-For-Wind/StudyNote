# C++ 并发编程

 C++并发编程是在C++11标准开始支持的，想要使用多线程，需要包含头文件 `#include <thread>`。并且在编译时需要链接多线程的库，`-lthread`。

## 前言

`thread`是C++标准库提供的类。



## 线程的创建

线程的创建实际上就是要先写一个函数，然后把这个函数作为入口参数传给`thread`的构造函数。

```cpp
#include <thread>
int dosomething(){
   
    return 0;
}

int main(){
    thread FirstThread(dosometing);//这里就已经完成了对新线程的创建了，
    
    return 0;
}
explicit
```



## join和detach

`join()`就是汇入，而`detach()`则是分离。

### join 汇入

当对一个对象调用`join()`方法时，主进程就会陷入阻塞，等待该对象，等该对象运行完成才会继续运行，并且将该对象线程的资源进行回收，但是这里会出现一个问题，就是调用`join()`方法的时机，如果在调用`join()`方法前，该线程就已经抛出错误，那么主线程就无法回收该线程的资源了，这应该很容易理解，因为我们调用join方法的目的，是为了等待线程的运行完毕并且汇入，但是当调用这个线程的时候该线程已经结束了，那么我们也就无法再回收它的资源了。

### joinable

joinable()方法可以用来检测当前的线程是否可以，进行 join() 和 detach() 操作，它会返回一个bool值，如果返回值为 true 则可以进行上述两个操作，如果返回值为 false 则不能进行这两个操作。



### detach 分离

使用`detach`可以让线程与当前线程分离，从而达到在后台运行的效果，但这也意味着它与主线程不能再通过`thread`进行直接的交互了，也就没法再次汇入。但C++运行库可以保证在线程退出时，相关资源能够正确回收。

分离线程通常称为_守护线程_(daemon threads)，在UNIX中守护线程是指没有任何显示接口并在后台运行的线程。





